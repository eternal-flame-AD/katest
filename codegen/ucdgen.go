package main

import (
	"archive/zip"
	"bytes"
	"encoding/xml"
	"go/format"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"time"
)

const ucdZipURL = "https://www.unicode.org/Public/UCD/latest/ucdxml/ucd.nounihan.flat.zip"

var hiraganaRegex = regexp.MustCompile("^HIRAGANA LETTER ([A-Z]+)$")
var katakanaRegex = regexp.MustCompile("^KATAKANA LETTER ([A-Z]+)$")

type Char struct {
	CodePoint string `xml:"cp,attr"`
	Name      string `xml:"na,attr"`
}

type Repertoire struct {
	Char []Char `xml:"char"`
}

type UCD struct {
	Description string     `xml:"desccription"`
	Repertoire  Repertoire `xml:"repertoire"`
}

func downloadAndParseUCD() *UCD {
	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	resp, err := client.Get(ucdZipURL)
	if err != nil {
		panic(err)
	}
	ucdZipBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	ucdZip, err := zip.NewReader(bytes.NewReader(ucdZipBytes), int64(len(ucdZipBytes)))
	if !strings.HasSuffix(ucdZip.File[0].Name, ".xml") {
		panic("downloaded file is not of xml extention")
	}
	ucdXML, err := ucdZip.File[0].Open()
	if err != nil {
		panic(err)
	}
	ucdXMLBytes, err := ioutil.ReadAll(ucdXML)
	if err != nil {
		panic(err)
	}
	res := new(UCD)
	if err := xml.Unmarshal(ucdXMLBytes, res); err != nil {
		panic(err)
	}

	return res
}

type charSet struct {
	Char   rune
	Romaji string
}

func cpToRune(cp string) rune {
	cpInt, _ := strconv.ParseUint(cp, 16, 32)
	return rune(cpInt)
}

var genCodeTpl = template.Must(template.New("code table").Parse(`// generated by ucdgen.go; DO NOT EDIT

package main

type Char struct {
	Char   rune
	Romaji string
	Type string
}

var hiraganaChars = []Char{
	{{range .Hiragana -}}
	  {
		Char: {{.Char}},
		Romaji: "{{.Romaji}}",
		Type: "hiragana",
	  },
	{{end}}
}

var katakanaChars = []Char{
	{{range .Katakana -}}
	  {
		Char: {{.Char}},
		Romaji: "{{.Romaji}}",
		Type: "katakana",
	  },
	{{end}}
}
`))

func main() {
	fn := os.Args[1]

	ucd := downloadAndParseUCD()

	var chars struct {
		Hiragana []charSet
		Katakana []charSet
	}
	for _, char := range ucd.Repertoire.Char {
		if matches := hiraganaRegex.FindStringSubmatch(char.Name); matches != nil {
			chars.Hiragana = append(chars.Hiragana, charSet{
				Char:   cpToRune(char.CodePoint),
				Romaji: matches[1],
			})
		} else if matches := katakanaRegex.FindStringSubmatch(char.Name); matches != nil {
			chars.Katakana = append(chars.Katakana, charSet{
				Char:   cpToRune(char.CodePoint),
				Romaji: matches[1],
			})
		}
	}

	codeBuf := bytes.NewBuffer([]byte{})
	if err := genCodeTpl.Execute(codeBuf, chars); err != nil {
		panic(err)
	}
	generatedCode, err := format.Source(codeBuf.Bytes())
	if err != nil {
		panic(err)
	}
	if err := os.WriteFile(fn+".go", generatedCode, 0644); err != nil {
		panic(err)
	}
}
